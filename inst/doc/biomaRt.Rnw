%\VignetteIndexEntry{Overview of the biomaRt package}
%\VignetteDepends{biomaRt}
%\VignetteKeywords{Annotation}
%\VignettePackage{biomaRt}
\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\author{Steffen Durinck$^\star$\footnote{durincks@mail.nih.gov}, Wolfgang Huber$^\P$\footnote{huber@ebi.ac.uk},\\Yves Moreau$^\ddagger$, Bart De Moor$^\ddagger$}
\begin{document}
\title{Description of the biomaRt package}

\maketitle
\begin{center} $^\star$Oncogenomics lab, NCI/NIH, Gaithersburg, MD, USA\\$^\ddagger$Department of Electronical Engineering, ESAT-SCD, K.U.Leuven, Belgium\\and $^\P$European Bioinformatics Institute, Hinxton, UK

 \end{center}

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The BioConductor \Rpackage{biomaRt} package provides and API in R to query BioMart databases such as Ensembl (http://www.ensembl.org), a software system which produces and maintains automatic annotation on metazoan genomes.  Two sets of functions are currently implemented.\\  
A first set of functions is tailored towards Ensembl and are a set of commonly used queries in microarray data analysis.
A second set of functions aims to mimic functionality of other BioMart APIs such as Martshell, Martview, etc. (see http://www.biomart.org for more information).  These functions are very general, and can be used with any BioMart system.  They allow retrieval of all information that other BioMart APIs provide. With these two sets of functions, one can for example annotate the features on your array with the latest annotations starting from identifiers such as affy ids, RefSeq, entrezgene,.. Annotation includes gene names, GO, OMIM, protein domains etc.  On top of this, biomaRt enables you to retrieve any type of information available from the BioMart databases from R.\\

\section{objects}

\subsection{Mart-class}

An object of the \Robject{Mart} class stores connections to BioMart databases and aditional information about the BioMarts. It has the following slots:
\begin{itemize}
\item \Robject{mysql}: Logical indicating if access to BioMart database should use MySQL or use the BioMart webservice over HTTP (default)
\item \Robject{connections}: Stores the MySQLConnections
\item \Robject{mysqldriver}:  Stores the MySQL driver
\item \Robject{mainTables}:  List of the main tables in  the BioMart database
\item \Robject{biomart}:  Name of the BioMart database
\item \Robject{host}:  Hostname of the BioMart database
\item \Robject{dataset}:  Name of the dataset that is in use
\item \Robject{filters}:  Environment that stores information on BioMart filters
\item \Robject{attributes}:  Environment that stores information on BioMart attributes
\end{itemize}


\section{Selecting a BioMart database and dataset}
In this section we describe a set of simple functions which are frequently used in the microarray community.  More powerful functions and data retrieval from all BioMart databases is described in the next section "Advanced data retrieval with BioMart API functions".

A first step when using biomaRt, is to check which BioMart web services are available.  The function \Rfunction{listMarts} will display all available BioMart web services   

<<echo=FALSE>>=
library(annotate)
options(width=120)
@

\begin{small}
<<>>=
library(biomaRt)
listMarts()
@
\end{small}

If the function \Rfunction{useMart} runs into proxy problems you should set your proxy first before calling any biomaRt functions.  
You can do this using the Sys.putenv command:

\begin{verbatim}
Sys.putenv("http\_proxy" = "http://my.proxy.org:9999")
\end{verbatim}

Next we need to select a BioMart database to use, which can be done with the \Rfunction{useMart} function.  Specify the web service by its name given by \Rfunction{listMarts}.  Here we choose to use the Ensembl BioMart web service.

<<>>=
ensembl=useMart("ensembl")
@

BioMart databases can contain several datasets.  In a next step we look at which datasets are available in the selected BioMart by using the function \Rfunction{listDatasets}.

\begin{small}
<<>>=
listDatasets(ensembl)
@
\end{small}

To select a dataset we can update the Mart object using the function \Rfunction{useDataset}.
\begin{verbatim}
ensembl = useDataset("hsapiens_gene_ensembl",mart=ensembl)
\end{verbatim}

Alternatively if the dataset one wants to use is known in advance this can be specified in the \Rfunction{useMart} function by:

<<>>=
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
@

\section{Simple biomaRt functions for frequently used queries to Ensembl}
Now that we selected a BioMart database and dataset, we can make biomaRt queries.
In this section we describe a set of simple functions which are frequently used in the microarray community.  More powerful functions and data retrieval from all BioMart databases are described in a later section: "Advanced data retrieval with BioMart".

\subsection{getGene}

The function \Rfunction{getGene} uses a vector of query ids to look up the name, description and chromosomal information of the corresponding gene. The type of identifier should be specified with the \textit{type} argument (this can have values like: entrezgene, refseq\_dna, unigene,affy\_hg\_u133\_plus\_2, etc...).  Possible values for the type argument can be retrieved with the listFilters function. The \textit{mart} argument should be used to specify which \Robject{Mart} object (which we generated above) to use.
\begin{scriptsize}
<<>>=
affyids=c("202763_at","209310_s_at","207500_at")
getGene(id=affyids, type="affy_hg_u133_plus_2",mart=ensembl)
@
\end{scriptsize}

Next we use \Rfunction{getGene} with a list of entrezgene identifiers.
\begin{scriptsize}
<<>>=
entrez=c("673","7157","837")
getGene(id=entrez, type="entrezgene",mart=ensembl)
@
\end{scriptsize}
\subsection{getGO}

The function \Rfunction{getGO} enables one to retrieve GO identifiers, descriptions and evidence codes starting from a variety of identifiers.
Identical to the \Rfunction{getGene} function, \Rfunction{getGO} takes the \textit{type} and \textit{mart} arguments.

\begin{scriptsize}
<<>>=
go = getGO(id=affyids[1], type="affy_hg_u133_plus_2",mart=ensembl)
go
@
\end{scriptsize}

\section{getSequence}

Sequences can be retrieved using the \Rfunction{getSequence} function either starting from chromosomal coordinates or identifiers.  The chromosome name can be specified using the \textit{chromosome} argument.  The \textit{start} and \textit{end} arguments are used to specify \textit{start} and \textit{end} positions on the chromosome. The type of sequence returned can be specified by the seqType argument which takes the following values: 'cdna';'peptide' for protein sequences;'3utr' for 3' UTR sequences,'5utr' for 5' UTR sequences; 'gene\_exon' for exon sequences only; 'transcript\_exon' for transcript specific exonic sequences only;'transcript\_exon\_intron' gives the full unspliced transcript, that is exons + introns;'gene\_exon\_intron' gives the exons + introns of a gene;'coding' gives the coding sequence only;'coding\_transcript\_flank' gives the flanking region of the transcript including the UTRs, this must be accompanied with a given value for the upstream or downstream attribute;'coding\_gene\_flank' gives the flanking region of the gene including the UTRs, this must be accompanied with a given value for the upstream or downstream attribute; 'transcript\_flank' gives the flanking region of the transcript exculding the UTRs, this must be accompanied with a given value for the upstream or downstream attribute; 'gene\_flank' gives the flanking region of the gene excluding the UTRs, this must be accompanied with a given value for the upstream or downstream attribute.
In MySQL mode the \Rfunction{getSequence} function is more limited and the sequence that is returned is the 5' to 3'+ strand of the genomic sequence, given a chromosome, as start and an end position.

First we retrieve the 5'UTR sequences of all genes on chromosome 3 between a given start and end position.  We also have to specify which type of identifier we want to retrieve together with the sequences, here we choose for entrezgene identifiers.
\begin{small}
\begin{verbatim}
> utr5 = getSequence(chromosome=3, start=185514033, end=185535839,
                      type="entrezgene",seqType="5utr", mart=ensembl)
> utr5
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
          V1               V2
  .....GAAGCGGTGGC ....   1981
\end{verbatim}
\end{scriptsize}

Next we retrieve the protein sequences given a list of entrezgene identifiers.  In  this case the type argument specifies which type of identifiers we are using.
To get an overview of other valid identifier types we refer to the \Rfunction{listFilters} function.

\begin{small}
\begin{verbatim}
> protein = getSequence(id=c(100, 5728),type="entrezgene",
                        seqType="peptide", mart=ensembl)
> protein
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
 peptide               entrezgene
 MAQTPAFDKPKVEL ...    100
 MTAIIKEIVSRNKRR ...   5728

\end{verbatim}
\end{scriptsize}

\section{exportFASTA}

The data.frames obtained by the getSequence function can be exported to FASTA files using the \Rfunction{exportFASTA} function.
One has to specify the data.frame to export and the filename using the file argument.

\section{getFeature}
The \Rfunction{getFeature} function enables us to select a set of features based on chromosomal coordinates or GO identifiers.
Select all Affymetrix identifiers on the hgu133plus2 chip for genes located on chromosome 16 between basepair 1100000 and 1250000.
\textit{getFeature} takes the \textit{type} argument to specify the type of identifiers that need to be retrieved.

\begin{small}
\begin{verbatim}
> features = getFeature( type = "affy_hg_u133_plus_2",
                         chromosome = "16", start = "1100000",
                         end = "1250000", mart=ensembl)
> features
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}

  ensembl_transcript_id chromosome_name start_position end_position affy_hg_u133_plus_2
1        ENST00000358590              16        1143739      1211772           222960_at
2        ENST00000358590              16        1143739      1211772           205845_at
3        ENST00000356546              16        1143739      1211772           222960_at
4        ENST00000356546              16        1143739      1211772           205845_at
5        ENST00000234798              16        1211659      1215257         220339_s_at
6        ENST00000357113              16        1218338      1220215         207741_x_at
7        ENST00000357113              16        1218338      1220215         215382_x_at
8        ENST00000357113              16        1218338      1220215         210084_x_at
9        ENST00000357113              16        1218338      1220215         205683_x_at
10       ENST00000357113              16        1218338      1220215         207134_x_at
11       ENST00000357113              16        1218338      1220215         217023_x_at
12       ENST00000357113              16        1218338      1220215         216474_x_at
13       ENST00000339687              16        1218338      1220215         215382_x_at
14       ENST00000339687              16        1218338      1220215         217023_x_at
15       ENST00000339687              16        1218338      1220215         216474_x_at
16       ENST00000338844              16        1230679      1232556         207741_x_at
17       ENST00000338844              16        1230679      1232556         215382_x_at
18       ENST00000338844              16        1230679      1232556         210084_x_at
19       ENST00000338844              16        1230679      1232556         205683_x_at
20       ENST00000338844              16        1230679      1232556         207134_x_at
21       ENST00000338844              16        1230679      1232556         217023_x_at
22       ENST00000338844              16        1230679      1232556         216474_x_at
23       ENST00000382804              16        1230679      1232556         207741_x_at
24       ENST00000382804              16        1230679      1232556         215382_x_at
25       ENST00000382804              16        1230679      1232556         210084_x_at
26       ENST00000382804              16        1230679      1232556         205683_x_at
27       ENST00000382804              16        1230679      1232556         207134_x_at
28       ENST00000382804              16        1230679      1232556         217023_x_at
29       ENST00000382804              16        1230679      1232556         216474_x_at
30       ENST00000382797              16        1246274      1248610           214568_at
31       ENST00000211076              16        1246274      1248610           214568_at
\end{verbatim}
\end{scriptsize}

Select all entrezgene ids which have a "MAP kinase activity" GO term associated with it.

\begin{small}
<<>>=
features=getFeature(type="entrezgene", GOID="GO:0004707", mart=ensembl)
features
@
\end{small}

\subsection{getSNP}
To retrieve SNP data we first have to connect to the snp BioMart database of Ensembl.

\begin{small}
\begin{verbatim}
> snpmart = useMart("snp", dataset = "hsapiens_snp")
Checking attributes and filters ... ok
> snp=getSNP(chromosome = 8, start = 148350, end = 148612,  mart = snpmart)
> snp
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}

        tscid  refsnp_id allele chrom_start chrom_strand
1  TSC1723456  rs3969741    C/A      148394            1
2  TSC1421398  rs4046274    C/A      148394            1
3  TSC1421399  rs4046275    A/G      148411            1
4                rs13291    C/T      148462            1
5  TSC1421400  rs4046276    C/T      148462            1
6              rs4483971    C/T      148462            1
7             rs17355217    C/T      148462            1
8             rs12019378    T/G      148471            1
9  TSC1421401  rs4046277    G/A      148499            1
10            rs11136408    G/A      148525            1
11 TSC1421402  rs4046278    G/A      148533            1
12            rs17419210    C/T      148533           -1
13            rs28735600    G/A      148533            1
14 TSC1737607  rs3965587    C/T      148535            1
15             rs4378731    G/A      148601            1
\end{verbatim}
\end{scriptsize}

\subsection{getHomolog}
BioMart takes advantage of the many species present in Ensembl to do homology mappings.  By using two datasets (i.e. two species), we can apply the \Rfunction{getHomolog} function to map identifiers from one species to the other.
Similar as the \Rfunction{getGene} function, we have to specify the identifier we start from using either the \textit{from.array} argument if the identifier comes from an affy array or else the \textit{from.type} argument if we use an other identifier.  The identifier we want to retrieve has to be specified by using the \textit{to.array} or \textit{to.type} arguments.\\
A generalized version of the \Rfunction{getHomolog} function is the \Rfunction{getLDS} function (see Advanced Queries section). \Rfunction{getLDS} enables one to combine two datasets (=species in Ensembl) and query any field from one dataset based on the other.

In a first example we start from a affy identifier of a human chip and we want to retrieve the identifiers of the corresponding homolog on a mouse chip. 
\begin{small}
\begin{verbatim}
> human = useMart("ensembl","hsapiens_gene_ensembl")
> mouse = useMart("ensembl","mmusculus_gene_ensembl")
> homolog = getHomolog( id = "1939_at", to.type = "affy_mouse430_2", from.type = 
                        "affy_hg_u95av2", from.mart = human, to.mart = mouse )

> homolog
       V1           V2
1 1939_at 1427739_a_at
2 1939_at 1426538_a_at

\end{verbatim}
\end{small}
An other example starts from a human RefSeq id and we want to retrieve the corresponding affy ids on the affy mouse430\_2 chip.

\begin{small}
\begin{verbatim}
> homolog = getHomolog( id = "NM_007294", to.type = "affy_mouse430_2",
                        from.type = "refseq_dna", from.mart = human,
                        to.mart = mouse )

> homolog
        V1           V2
1 NM_007294   1424629_at
2 NM_007294   1451417_at
3 NM_007294 1424630_a_at

\end{verbatim}
\end{small}

\section{Advanced data retrieval with BioMart}

The previous functions were all tailored to the Ensembl BioMart web service.  In this section we will see biomaRt functions that can be used to retrieve everything that is available by any BioMart.  Three terms have to be introduced first: filters, attributes and values.
A filter defines a restriction on the query.  For example you want to restrict the output to all genes located on the human X chromosome then the filter \textit{chromosome\_name} can be used with value 'X'.\\
Attributes define the values we are interested in to retrieve.  For example we want to retrieve the gene symbols or chromosomal coordinates.\\
We will first demonstrate the use of filters and attributes with Ensembl and use it with other BioMarts.

\subsection{listFilters and filterSummary}
The function \Rfunction{listFilters} can be used to retrieve all available filters in a dataset.

\begin{small}
<<>>=
filters =  listFilters(ensembl)
filters[1:10,]
@
\end{small}

In BioMart databases, filters can be grouped.
Ensembl for example contains the filter groups GENE:, REGION:, ...
An overview of the categories and groups for attributes present in the respective BioMart dataset can be obtained with the \Rfunction{filterSummary} function.

\begin{small}
<<>>=
summaryF = filterSummary(ensembl)
summaryF[1:5,]
@
\end{small}

To show us a smaller list of filters which belog to a specified group or category we can now specify this in the \Rfunction{listFilters} function as follows:

\begin{small}
<<>>=
listFilters(ensembl, group = "REGION:")
@
\end{small}

We now get a short list of filters related to the region where the genes are located.


\subsection{listAttributes and attributeSummary}
The \Rfunction{listAttributes} function can be used to see which attributes are available in the selected dataset.

\begin{small}
<<>>=
attrib = listAttributes(ensembl)
attrib[1:10,]
@
\end{small}

For large BioMart databases such as Ensembl, the number of attributes displayed by the \Rfunction{listAttributes} function can be very large. 
In BioMart databases, attributes are put together in categories, such as Sequences, Features, Homologs for Ensembl, and within these categories, attributes can be grouped.
The Features category of Ensembl for example contains the attribute groups GENE:, REGION:, ...
An overview of the categories and groups for attributes present in the respective BioMart dataset can be obtained with the \Rfunction{attributeSummary} function.

\begin{small}
<<>>=
summaryA = attributeSummary(ensembl)
summaryA[1:10,]
@
\end{small}

To show us a smaller list of attributes which belog to a specified group or category we can now specify this in the \Rfunction{listAttributes} function as follows:

\begin{small}
<<>>=
listAttributes(ensembl, category  = "Features", group = "GENE:")
@
\end{small}

We now get a short list of attributes related to the region where the genes are located.


\subsection{getBM}
Now that we know what filters and attributes are we can make a biomaRt query using the \Rfunction{getBM} function. An easy query could be to retrieve  the HUGO symbols, chromosome name and band for a set of affy identifiers.

\begin{small}
<<>>=
getBM(attributes = c("affy_hg_u95av2","hgnc_symbol","chromosome_name","band"),
            filters="affy_hg_u95av2",
             values=c("1939_at","1503_at","1454_at"), mart=ensembl)
@
\end{small}

\subsection{Example queries getBM}

Below we describe some more complicated examples.

\subsubsection{Using more than one filter}
The \Rfunction{getBM} function enables you to use more than one filter.  In this case  the filter argument should be a vector with the filter names.  The values should be a list, where the first element of the list corresponds to the first filter and the second list element to the second filter and so on.  The elements of this list are vectors containing the possible values for the corresponding filters.
\begin{small}
\begin{verbatim}
 go=c("GO:0051330","GO:0000080","GO:0000114","GO:0000082",
       "GO:0000083","GO:0045023","GO:0031568","GO:0031657")
 chrom=c(1,2,"Y")
 getBM(attributes=c("hgnc_symbol","agilent_probe","chromosome_name",
                     "ensembl_transcript_id"),
        filters=c("go","chromosome_name"),
        values=list(go,chrom), mart=ensembl)
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
   hgnc_symbol agilent_probe chromosome_name ensembl_transcript_id
1         CUL3  A_24_P140030               2       ENST00000264414
2         CUL3  A_23_P209288               2       ENST00000264414
3        ACVR1   A_23_P79221               2       ENST00000263640
4        ACVR1   A_23_P79218               2       ENST00000263640
5         RCC1                             1       ENST00000373834
6         RCC1   A_23_P46309               1       ENST00000373833
7         RCC1   A_23_P46306               1       ENST00000373833
8         RCC1   A_23_P46309               1       ENST00000373832
9         RCC1   A_23_P46306               1       ENST00000373832
10        CDC7  A_23_P148807               1       ENST00000370415
11        CDC7  A_23_P148807               1       ENST00000234626
12      PPP1CB  A_23_P425579               2       ENST00000379582
13      PPP1CB  A_32_P102935               2       ENST00000379582
14       SPDYA  A_23_P425579               2       ENST00000379582
15       SPDYA  A_32_P102935               2       ENST00000379582
16      PPP1CB  A_23_P425579               2       ENST00000379580
17      PPP1CB  A_32_P102935               2       ENST00000379580
18       SPDYA  A_23_P425579               2       ENST00000379580
19       SPDYA  A_32_P102935               2       ENST00000379580
20      PPP1CB  A_23_P425579               2       ENST00000334056
21      PPP1CB  A_32_P102935               2       ENST00000334056
22       SPDYA  A_23_P425579               2       ENST00000334056
23       SPDYA  A_32_P102935               2       ENST00000334056
24        RHOU  A_23_P114814               1       ENST00000366691
25        RHOU   A_24_P62530               1       ENST00000366691
26        E2F6   A_32_P12610               2       ENST00000307236
27        E2F6  A_23_P170774               2       ENST00000307236
28        E2F6   A_32_P27271               2       ENST00000307236
29        E2F6  A_32_P230720               2       ENST00000307236
30        E2F6    A_23_P6312               2       ENST00000307236
31        GFI1  A_23_P257365               1       ENST00000370332
32        GFI1  A_23_P257365               1       ENST00000294702
33        MDM4  A_24_P927377               1       ENST00000367183
34        MDM4  A_24_P778649               1       ENST00000367183
35        MDM4  A_24_P362432               1       ENST00000367183
36        MDM4  A_23_P103503               1       ENST00000367183
37        MDM4  A_23_P103502               1       ENST00000367183
38        MDM4  A_23_P170969               1       ENST00000367183

\end{verbatim}
\end{scriptsize}

\subsubsection{Using a BioMart other than Ensembl}

To demonstrate the use of the biomaRt package with non-Ensembl databases the next query is performed using the Wormbase BioMart (WormMart).
We connect to Wormbase, select the gene dataset to use and have a look at the available attributes and filters.  Then we use a list of gene names as filter and retrieve associated RNAi identifiers together with a description of the RNAi phenotype.
<<echo=TRUE, eval=FALSE>>=
wormbase=useMart("wormbase",dataset="gene")
listFilters(wormbase)
listAttributes(wormbase)
getBM(attributes=c("name","rnai","rnai_phenotype","phenotype_desc"),
                     filters="gene_name", values=c("unc-26","his-33"),
                     mart=wormbase)
     
@
\begin{scriptsize}
\begin{verbatim}
     name  rnai               rnai_phenotype                                     phenotype_desc

1  his-33 WBRNAi00000104   Emb | Nmo         embryonic lethal | Nuclear morphology alteration in early embryo
2  his-33 WBRNAi00012233   WT                                             wild type morphology
3  his-33 WBRNAi00024356   Ste                                                          sterile
4  his-33 WBRNAi00025036   Emb                                                 embryonic lethal
5  his-33 WBRNAi00025128   Emb                                                 embryonic lethal
6  his-33 WBRNAi00025393   Emb                                                 embryonic lethal
7  his-33 WBRNAi00025515   Emb | Lva | Unc                 embryonic lethal | larval arrest | uncoordinated
8  his-33 WBRNAi00025632   Gro | Ste                                            slow growth | sterile
9  his-33 WBRNAi00025686   Gro | Ste                                            slow growth | sterile
10 his-33 WBRNAi00025785   Gro | Ste                                            slow growth | sterile
11 his-33 WBRNAi00026259   Emb | Gro | Unc                   embryonic lethal | slow growth | uncoordinated
12 his-33 WBRNAi00026375   Emb                                                 embryonic lethal
13 his-33 WBRNAi00026376   Emb                                                 embryonic lethal
14 his-33 WBRNAi00027053   Emb | Unc                                 embryonic lethal | uncoordinated
15 his-33 WBRNAi00030041   WT                                             wild type morphology
16 his-33 WBRNAi00031078   Emb                                                 embryonic lethal
17 his-33 WBRNAi00032317   Emb                                                 embryonic lethal
18 his-33 WBRNAi00032894   Emb                                                 embryonic lethal
19 his-33 WBRNAi00033648   Emb                                                 embryonic lethal
20 his-33 WBRNAi00035430   Emb                                                 embryonic lethal
21 his-33 WBRNAi00035860   Egl | Emb                             egg laying defect | embryonic lethal
22 his-33 WBRNAi00048335   Emb | Sister Chromatid Separation abnormal (Cross-eyed)   embryonic lethal |
23 his-33 WBRNAi00049266   Emb | Sister Chromatid Separation abnormal (Cross-eyed)     embryonic lethal |
24 his-33 WBRNAi00053026   Emb | Sister Chromatid Separation abnormal (Cross-eyed)     embryonic lethal |
25 unc-26 WBRNAi00021278   WT                                             wild type morphology
26 unc-26 WBRNAi00026915   WT                                             wild type morphology
27 unc-26 WBRNAi00026916   WT                                             wild type morphology
28 unc-26 WBRNAi00027544   Unc                                                    uncoordinated
29 unc-26 WBRNAi00049565   WT                                             wild type morphology
30 unc-26 WBRNAi00049566   WT                                             wild type morphology
\end{verbatim}
\end{scriptsize}

\subsection{getLDS and linking BioMart datasets}

The \Rfunction{getLDS} (Get Linked Dataset) function provides functionality to link 2 BioMart datasets which each other and construct a query over the two datasets.
The usage of getLDS is very similar to \Rfunction{getBM}.  The linked dataset is provided by a separate Mart object and one has to specify filters and attributes for the linked dataset.  Note that this function only works in web service mode.  Filters can either be applied to both datasets or to one of the datasets. When used with Ensembl, \Rfunction{getLDS} is a generalized version of the \Rfunction{getHomolog} function.
Below is an example on how to use \Rfunction{getLDS}.

\begin{scriptsize}
\begin{verbatim}
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
getLDS(attributes = c("hgnc_symbol","chromosome_name", "start_position"),
       filters = "hgnc_symbol", values = "TP53",mart = human,
      attributesL = c("chromosome_name","start_position"), martL = mouse)

   V1 V2      V3 V4       V5
1 TP53 17 7512464 11 69396600
2 TP53 17 7512464 11 69396600
\end{verbatim}
\end{scriptsize}

\section{Local BioMart databases}

The biomaRt package can be used with a local install of a public BioMart database or a locally developed BioMart database.
In order for biomaRt to recognize the database as a BioMart, make sure that the local database you create has a name conform with \begin{verbatim} database_mart_version \end{verbatim} where database is the name of the database and version is a version number.  No more underscores than the ones showed should be present in this name. A possible name is for example \begin{verbatim} ensemblLocal\_mart\_42 \end{verbatim}.
\subsection{Minimum requirements for local database installation}
One needs to first download the SQL code to generate the database.  For ensembl\_mart\_42 this was in the file ensembl\_mart\_42.sql.gz. 
Then run this SQL code to generate the tables of your local database:

\begin{verbatim}
mysql -D ensembl_mart_42 -u username -p < ensembl_mart_42.sql
\end{verbatim}

Once the tables are created you need to fill the following tables with the downloaded data:
\begin{scriptsize}
\begin{verbatim}
Essential tables:

meta_conf__dataset__main.txt.table
meta_conf__xml__dm.txt.table

You can install them from your MySQL command line with:

LOAD DATA INFILE 'meta_conf__dataset__main.txt.table' INTO TABLE meta_conf__dataset__main;
LOAD DATA INFILE 'meta_conf__xml__dm.txt.table' INTO TABLE meta_conf__xml__dm;
\end{verbatim}
\end{scriptsize}

Next you load all the tables that have the name of your species of interest with with the corresponding table data.
Once the local database is installed you can use biomaRt on this database by:
\begin{scriptsize}
\begin{verbatim}
mart=useMart("ensembl_mart_42", mysql=TRUE, host="localhost", user="****", password="****", 
              local=TRUE, dataset="hsapiens_gene_ensembl")
\end{verbatim}
\end{scriptsize}

For more information on how to install a public BioMart database see:  http://www.biomart.org/install.html and follow link databases.
\section{Session Info}
<<>>=
sessionInfo()
warnings()
@
\end{document}
