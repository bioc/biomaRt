%\VignetteIndexEntry{biomaRt}
%\VignetteDepends{biomaRt}
%\VignetteKeywords{biomaRt}
%\VignettePackage{biomaRt}
%\documentclass[12pt, a4paper]{article}
\documentclass[12pt]{article}

\usepackage{amsmath,epsfig,psfig,pstricks,fullpage}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}




\author{Steffen Durinck$^\ddagger$\footnote{Steffen.Durinck@esat.kuleuven.ac.be}, Wolfgang Huber$^\P$\footnote{huber@ebi.ac.uk},\\Yves Moreau$^\ddagger$, Bart De Moor$^\ddagger$}
\begin{document}
\title{Description of the biomaRt package}

\maketitle
\begin{center} $^\ddagger$Department of Electronical Engineering, ESAT-SCD, K.U.Leuven,\\ Kasteelpark Arenberg 10, 3001 Leuven-Heverlee, Belgium, \url{http://www.esat.kuleuven.ac.be/~dna/BioI}\\and $^\P$European Bioinformatics Institute, Hinxton, UK

 \end{center}

%library(tools)
%Rnwfile<- file.path("/home/steffen/programming/R/biomaRt/inst/doc/biomaRt.Rnw")
%Sweave(Rnwfile,pdf=TRUE,eps=TRUE,stylepath=TRUE,driver=RweaveLatex())

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The BioConductor \Rpackage{biomaRt} package provides and API in R to query BioMart databases such as Ensembl (http://www.ensembl.org), a software system which produces and maintains automatic annotation on metazoan genomes.  Two sets of functions are currently implemented.\\  
A first set of functions is tailored towards Ensembl and are a set of commonly used queries in microarray data analysis.
A second set of functions aims to mimic functionality of other BioMart APIs such as Martshell, Martview, etc. (see http://www.biomart.org for more information).  These functions are very general, and can be used with any BioMart system.  They allow retrieval of all information that other BioMart APIs provide. With these two sets of functions, one can for example annotate the features on your array with the latest annotations starting from identifiers such as affy ids, RefSeq, entrezgene,.. Annotation includes gene names, GO, OMIM annotation, etc.  On top of this, biomaRt enables you to retrieve any type of information available from the BioMart databases from R.\\

\section{objects}

\subsection{Mart-class}

An object of the \Robject{Mart} class stores connections to BioMart databases and aditional information about the BioMarts. It has the following slots:
\begin{itemize}
\item \Robject{mysql}: Logical indicating if access to BioMart database should use MySQL or use the BioMart webservice over HTTP (default)
\item \Robject{connections}: Stores the MySQLConnections
\item \Robject{mysqldriver}:  Stores the MySQL driver
\item \Robject{mainTables}:  List of the main tables in  the BioMart database
\item \Robject{biomart}:  Name of the BioMart database
\item \Robject{host}:  Hostname of the BioMart database
\item \Robject{dataset}:  Name of the dataset that is in use
\item \Robject{filters}:  Environment that stores information on BioMart filters
\item \Robject{attributes}:  Environment that stores information on BioMart attributes
\end{itemize}


\section{Simple biomaRt functions for frequently used queries to Ensembl}
In this section we describe a set of simple functions which are frequently used in the microarray community.  More powerful functions and data retrieval from all BioMart databases is described in the next section "Advanced data retrieval with BioMart API functions".

\subsection{Selecting a  BioMart database to use}

A first step in using the biomaRt package is to connect to a BioMart database. The function martConnect establishes a connection with one or more of the following BioMart databases: snp, ensembl, sequence and vega.  Default this function will connect to public BioMart databases.  If no biomart is specified, only a connection to ensembl will be established.  If you want to use local BioMart install you have to set the local argument to TRUE and specify host, password and user details in the corresponding arguments.   

\subsubsection{\Rfunction{useMart}}

<<echo=FALSE>>=
library(annotate)
@
<<>>=
library(biomaRt)
@
<<echo=TRUE, eval=FALSE>>=
#select a BioMart database to use.
mart <- useMart("ensembl")
@

\subsubsection{\Rfunction{martDisconnect}}

When using MySQL access, you can only hold a limited number of connections with different BioMarts.  The function martDisconnect can be used to close a mart connection.

<<echo=TRUE, eval=FALSE>>=

#Disconnect from BioMart databases
martDisconnect(mart)
 
@

\subsection{Annotating identifiers with gene information}

The function \Rfunction{getGene} uses a query id to look up the name, description and chromosomal information of the corresponding gene.
Currently the \Rfunction{getGene} function takes identifiers from entrezgene, ensembl, refseq, affy, hugo, unigene and embl.\\
The {\it id} argument is either a vector of identifiers or a single identifier to be annotated.\\
The {\it array} argument takes affy array identifiers as values.  A list of possible identifiers supported by the package can be obtained by executing the function \Rfunction{getAffyArrays}.\\
The {\it mart} argument is a mart connection, which was obtained using the method \Rfunction{martConnect}.\\
The {\it type} takes the values of 'entrezgene','refseq','hugo', 'ensembl' and 'embl' to clarify which type of identifier is specified in the id argument.\\

First we select the BioMart databases and the dataset we want to use.  

<<>>=
mart <- useMart("ensembl",dataset="hsapiens_gene_ensembl") 
@
Then we check which affy arrays are available:

<<>>=
getAffyArrays(mart)
@

Assume now that we have some upregulated features that we want to annotate. To get the gene information on a certain affy array do:

<<>>=
upregulated <- c("210708_x_at","202763_at","211464_x_at")
getGene( id = upregulated, array = "affy_hg_u133_plus_2", mart = mart)
@
When using other id's we have to specify the \texttt{type} and \texttt{species}, use the function \Rfunction{getSpecies} to find valid species names.

<<>>=
getGene(id=100,type="entrezgene",mart=mart)
@


\subsubsection{GO annotation}

Gene Onotology annotation can be retrieved with the function \Rfunction{getGO}.  The arguments are the same as the function \Rfunction{getGene}.

<<>>=
go <- getGO( id = "203140_at", array = "affy_hg_u133_plus_2", mart = mart)
go
@

\subsubsection{OMIM annotation}

OMIM annotation can be retrieved with the function \Rfunction{getOMIM}.  The arguments are the same as the function \Rfunction{getGene}.


\subsubsection{INTERPRO protein domains}

INTERPRO protein domains of the corresponding proteins can be searched with the function \Rfunction{getINTERPRO}. Again the arguments are the same as the function \Rfunction{getGene}.  

<<>>=

getINTERPRO(id="1939_at",array="affy_hg_u95av2",mart=mart)

@


\subsection{Homology mapping}

This function maps homologs of genes of one species to another species.
To use the function one needs two instances of a mart object where two different datasets are selected e.g. hsapiens\_gene\_ensembl and mmusculus\_gene\_ensembl if you want to map homologues between these two species.
Now we can look for homologs:

<<>>=
from.mart=useMart("ensembl",dataset="hsapiens_gene_ensembl")
to.mart=useMart("ensembl",dataset="mmusculus_gene_ensembl")

getHomolog(id = 2,from.type = 'entrezgene', to.type = 'refseq',from.mart = from.mart, to.mart = to.mart)

@


\subsection{Identify subsets of genes for further analysis with the \Rfunction{getFeature} function}

The function \Rfunction{getFeature} is a general function to look up identifiers which pass a certain filter.  A first such a filter is to look for identifiers that correspond to genes with a given symbol.  If the array argument is given then affy identifiers from that array will be returned.  For retrieving other identifiers one has to specify the species and the type of identifier to retrieve.\\

<<>>=
getFeature(symbol="BRCA2",array="affy_hg_u133_plus_2",mart=mart)
@

A second possible filter is to look for ids which have a certain OMIM disease term attached to them (this only works for hsapiens).
Similarly one can look for ids that have a certain GO annotation e.g. retrieve all affy id's on the hgu133plus2 array which have protein-tyrosine kinase activity.\\

An other filter uses the position of genes on the genome.  One can query for all genes on a certain chromosome:

<<>>=
ychrom <- getFeature(chromosome="Y",type="entrezgene", mart=mart)
ychrom[1:10,]
@

Or query for genes that lay in a particular region:\\

<<>>=
getFeature(chromosome=1,start=2800000, end = 3200000, type="entrezgene",mart=mart)
@

\subsection{Sequence information}

The function \Rfunction{getSequence} retrieves the sequence given its chromosome, start and end position.
\subsection{Single Nucleotide Polymorphisms}

The function \Rfunction{getSNP} retrieves all SNP's between a given a start and end position on a gives chromosome..
Note:  make sure you have a Mart object with connections to ensembl and snp

<<>>=

mart=useMart("snp", dataset="hsapiens_snp")
getSNP(chromosome = 8, start = 148350, end = 148612, mart = mart)

@

\subsection{More exotic functions}
\subsubsection{\Rfunction{getPossibleXrefs}}

This function retrieves the possible cross-references present in Ensembl.  This is a very general function to see what can be extracted from Ensembl.  The results of this function can be used in the getXref function to extract the data of interest.

\subsubsection{\Rfunction{getXref}}

This function retrieves any cross reference in Ensembl.  It can for example be used to map different affymetrix array within one species.
E.g. starting from an affy id of chip hgu95av2 and id 1939\_at, look for corresponding affy identifiers on the affy hgu133plus2 chip.


\section{Advanced data retrieval with BioMart API functions}
In this section we'll discuss functions that resemble other BioMart APIs such as Martshell (see: http://www.biomart.org for more info).   These functions are very general and can be used on all BioMart databases.  The order in which the functions are discussed is the usual order of how you should use them.

\subsection{listMarts}

The \Rfunction{listMarts} lists the possible BioMarts where we can connect to.

<<>>=
library(biomaRt)
marts <- listMarts()
marts
@

\subsection{useMart}

Here we select from the list of possible BioMart databases, a BioMart that we want to use.
<<>>=

mart <- useMart("ensembl")
@
\subsection{listDatasets}

Next we want to select a specific dataset of the selected BioMart. To see which dataset is available we use the function \Rfunction{listDatasets}.

<<>>=
listDatasets(mart)
@

\subsection{useDataset}

To actually use a dataset we use the function \Rfunction{useDataset} to update our Mart object so it contains the configuration information of the dataset of interest.

<<>>=

mart<-useDataset(dataset="hsapiens_gene_ensembl",mart=mart)

@

\subsection{Filter, Values and Attributes}

In BioMart, a filter is used to search a set of attributes that have a specified value for that filter.  To explain this better lets consider the following use case.  We want to get the gene symbol, chromosome name and band of the following features on the affy hgu95av2 chip: 1939\_at,2082\_s\_at and 1454\_at.  In this case the attributes are gene symbol, chromosome name and band, they are the information we want to retrieve.  The filter is the hgu95av2 chip and as values for this filter we use the affy identifiers we want to retrieve the information from.   
In BioMart a list of possible attributes that we can query for can be retrieved by using the function \Rfunction{listAttributes}

<<>>=

attributes <- listAttributes(mart) 
attributes[1:10]

@

Similarly a list of possible filters can be obtained with the function \Rfunction{listFilters}.

<<>>=
filters <- listFilters(mart)
filters[1:10]
@

To get the information from our example we can use the function \Rfunction{getBM}, using valid attributes and filter.

<<>>=
getBM(attributes=c("affy_hg_u95av2","hgnc_symbol"),filter="affy_hg_u95av2",values=c("1939_at","1000_at"), mart=mart)
@

As you see multiple attributes can be retrieved at once but in the current version of biomaRt there is the restriction that the attributes which are queried together, should somehow be of a similar type, e.g. chromosome band and chromosome name or e.g. allele, SNP, and frequency of snp.\\ 
\section{Local BioMart databases}
The biomaRt package can be used with a local install of a public BioMart database or a locally developed BioMart database.
In order for biomaRt to recognize the database as a BioMart, make sure that the local database you create has a name conform with \begin{verbatim} database_mart_version \end{verbatim} where database is the name of the database and version is a version number.  No more underscores than the ones showed should be present in this name. A possible name is for example \begin{verbatim} ensemblLocal_mart_36 \end{verbatim}.
For more information on how to install a public BioMart database see:  http://www.biomart.org/install.html and follow link databases.

\end{document}
